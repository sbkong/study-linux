# Chapter.10 프로세스 관리
**프로세스(Process)** 는 실행 중인 프로그램의 인스턴스를 의미한다. 이는 단순히 프로그램의 코드뿐만 아니라 해당 프로그램이 실행되면서 필요한 모든 자원, 즉 메모리, 파일 디스크립터, CPU 시간 등을 포함한다. 리눅스에서는 각 프로세스가 고유한 프로세스 식별자(PID)를 가지며, 커널에 의해 관리된다. 프로세스는 부모-자식 관계를 가지며, 이러한 관계는 포크(fork) 시스템 호출을 통해 형성된다. 프로세스는 실행, 대기, 중지 등의 다양한 상태를 가질 수 있다.

## 프로세스의 이해
#### 프로세스 상태 정의
리눅스에서 프로세스는 커널에 의해 관리되며, 각 프로세스는 고유한 프로세스 식별자(PID)를 부여받는다. 프로세스는 다음과 같은 다양한 상태를 가질 수 있다.

- **실행 중(Running)**: CPU에서 실행되고 있는 상태.
- **대기 중(Waiting)**: 특정 조건이 충족되기를 기다리는 상태. 단기 대기와 장기 대기로 나뉨.
- **중지됨(Stopped)**: 일시적으로 실행이 중단된 상태.
- **좀비(Zombie)**: 실행이 종료되었지만 부모 프로세스가 아직 종료 상태를 읽지 않은 상태.
- **고아(Orphan)**: 부모 프로세스가 종료되어 부모가 없는 상태가 된 프로세스. 자원 누수를 막기 위해 고아 프로세스는 자동으로 `init` 프로세스(PID 1)가 새 부모 프로세스로 할당하여 관리한다.
#### 프로세스 생성과 종료
- **생성**: 새로운 프로세스는 기존 프로세스가 `fork()` 시스템 호출을 통해 복제됨으로써 생성된다. 이렇게 생성된 프로세스를 '자식 프로세스'라고 부른다.
- **실행**: `exec()` 시스템 호출을 통해 자식 프로세스는 새로운 프로그램을 실행할 수 있다.
- **종료**: `exit()` 시스템 호출을 통해 프로세스는 종료된다. 종료된 프로세스는 부모 프로세스가 `wait()` 시스템 호출을 통해 종료 상태를 읽을 때까지 좀비 상태로 남아 있다.

```bash
pstree
```
- 프로세스들을 트리(tree) 구조로 출력한다.

### `ps` 명령어

`ps` 명령어는 현재 실행 중인 프로세스의 상태를 확인하는 데 사용되는 유틸리티다. 시스템에서 어떤 프로세스가 실행 중인지, 각 프로세스의 상태, CPU 및 메모리 사용량 등을 확인할 수 있다. `ps` 명령어는 프로세스 목록을 순간의 스냅샷으로 제공하며, 지속적인 업데이트는 하지 않는다.
#### 자주 사용하는 옵션
- `-e`: 시스템의 모든 프로세스를 표시한다.
- `-f`: 풀 포맷(full-format)으로 출력한다.
- `-u <사용자>`: 특정 사용자의 프로세스를 표시한다.
- `-aux`: 모든 프로세스를 상세하게 출력한다.
- `-ef`: 풀 포맷으로 모든 프로세스를 표시한다.
#### 코드 스니펫
```bash
# 시스템의 모든 프로세스를 표시
ps -e

# 풀 포맷으로 프로세스를 표시
ps -f

# 특정 사용자(user)의 프로세스를 표시 (여기서는 'user'를 사용자의 이름으로 대체)
ps -u user

# 모든 프로세스를 상세하게 표시
ps -aux

# 풀 포맷으로 모든 프로세스를 표시
ps -ef
```

이와 같이 `ps` 명령어는 다양한 옵션과 함께 사용되어 시스템의 프로세스 상태를 모니터링하는 데 유용하다. 또한, 다음과 같이 파이프라인 명령어를 이용해 원하는 프로세스만 모니터링할 수도 있다.

```bash
# python 이름을 포함하는 프로세스만 표시
ps -ef | grep python
```

### `kill` 시그널

`kill` 명령어는 특정 프로세스에 시그널을 보내는 데 사용되는 유틸리티다. 일반적으로 프로세스를 종료하기 위해 사용되지만, 다양한 시그널을 통해 다른 동작을 수행할 수도 있다. `kill` 명령어는 프로세스 ID(PID)를 인수로 받아 해당 프로세스에 시그널을 보낸다.

시그널 없이 일반적으로 프로세스를 종료할 때는 다음과 같이 사용한다.
```bash
# PID 2373인 프로세스 종료
kill 2373
```
#### 자주 사용하는 시그널(옵션)
- `SIGTERM (15)`: 정상 종료 요청 시그널이다. 프로세스가 종료되기 전에 정리 작업을 할 수 있다.
- `SIGKILL (9)`: 강제 종료 시그널이다. 프로세스가 즉시 종료되며, 정리 작업을 수행할 기회를 주지 않는다.
- `SIGHUP (1)`: 프로세스가 제어 터미널을 잃었음을 알리는 시그널이다. 일반적으로 데몬 프로세스를 재시작하는 데 사용된다.
- `SIGINT (2)`: 인터럽트 시그널로, 일반적으로 Ctrl+C를 통해 보내진다.
- `SIGSTOP (19)`: 프로세스를 일시 중지하는 시그널이다.
- `SIGCONT (18)`: 일시 중지된 프로세스를 재개하는 시그널이다.

```bash
# PID 1234번 프로세스에 SIGTERM 시그널(정상 종료)을 보낸다
kill -15 1234

# PID 1234번 프로세스에 SIGKILL 시그널(강제 종료)을 보낸다
kill -9 1234

# PID 1234번 프로세스에 SIGHUP 시그널(재시작)을 보낸다
kill -1 1234

# PID 1234번 프로세스에 SIGINT 시그널(인터럽트)을 보낸다
kill -2 1234

# PID 1234번 프로세스에 SIGSTOP 시그널(일시 중지)을 보낸다
kill -19 1234

# PID 1234번 프로세스에 SIGCONT 시그널(재개)을 보낸다
kill -18 1234
```

다중으로 프로세스를 종료할 때에는 `killall` 명령어를 사용한다.
```
killall [process 이름]
```
killall은 여러 프로세스를 PID 대신 이름으로 지정하여, 다중으로 종료시킬 수 있다. 재미있게도, 절대로 자기 자신을 종료하지 않는 특징을 가진다.

###  멀티 태스킹(Multi-tasking) 용어

#### 백그라운드 (Background)
백그라운드는 사용자가 명령어를 입력한 쉘과 상호작용하지 않고, 독립적으로 실행되는 작업을 의미한다. 백그라운드 작업은 터미널을 점유하지 않으며, 사용자는 동일한 터미널에서 다른 작업을 계속 수행할 수 있다.
#### 포그라운드 (Foreground)
포그라운드는 사용자가 명령어를 입력한 쉘과 직접 상호작용하는 작업을 의미한다. 포그라운드 작업은 터미널을 점유하며, 작업이 완료될 때까지 터미널에서 다른 명령을 입력할 수 없다.
#### 서스펜드 (Suspend)
서스펜드는 일시적으로 중지된 작업을 의미한다. 사용자는 `Ctrl+Z`를 눌러 현재 실행 중인 포그라운드 작업을 서스펜드 상태로 만들 수 있다. 서스펜드된 작업은 나중에 백그라운드 또는 포그라운드에서 재개될 수 있다. (ex. suspend 함수 선언 등)

### `jobs` 명령어

`jobs` 명령어는 현재 쉘 세션에서 실행 중인 백그라운드 및 서스펜드된 작업의 목록을 표시하는 데 사용되는 유틸리티이다. 각 작업에는 고유한 작업 번호가 부여되며, 이 번호를 통해 특정 작업을 식별하고 제어할 수 있다.

#### 자주 사용하는 옵션
- `-l`: 각 작업의 프로세스 ID(PID)도 함께 표시한다.
- `-p`: 각 작업의 프로세스 ID만 표시한다.
- `-n`: 최근에 상태가 변경된 작업만 표시한다.
- `-r`: 실행 중인 작업만 표시한다.
- `-s`: 서스펜드된 작업만 표시한다.

```bash
# 현재 쉘 세션의 모든 백그라운드 및 서스펜드된 작업을 표시
jobs

# 작업 번호와 함께 프로세스 ID를 표시
jobs -l

# 프로세스 ID만 표시
jobs -p

# 최근에 상태가 변경된 작업만 표시
jobs -n

# 실행 중인 작업만 표시
jobs -r

# 서스펜드된 작업만 표시
jobs -s

```

### `bg` 및 `fg` 명령어

#### `bg` 명령어

`bg` 명령어는 서스펜드된 작업을 백그라운드에서 재개하는 데 사용되는 유틸리티이다. 서스펜드된 작업을 백그라운드에서 실행하면, 터미널을 점유하지 않으므로 사용자는 다른 작업을 계속 수행할 수 있다.
```bash
# 가장 최근에 서스펜드된 작업을 백그라운드에서 재개
bg

# 특정 작업 번호를 지정하여 해당 작업을 백그라운드에서 재개
bg %<작업 번호>
```

#### `fg` 명령어

`fg` 명령어는 백그라운드에서 실행 중이거나 서스펜드된 작업을 포그라운드에서 재개하는 데 사용되는 유틸리티이다. 포그라운드에서 작업을 재개하면, 해당 작업은 터미널을 점유하게 되며, 사용자는 작업이 완료될 때까지 다른 명령을 입력할 수 없다.
```bash
# 가장 최근에 백그라운드에서 실행 중이거나 서스펜드된 작업을 포그라운드에서 재개
fg

# 특정 작업 번호를 지정하여 해당 작업을 포그라운드에서 재개
fg %<작업 번호>
```
### 데몬(Daemon)이란?

데몬(Daemon)은 백그라운드에서 실행되며 시스템이 운영되는 동안 항상 실행되는 백그라운드 프로세스이다. 데몬은 주로 서버, 서비스, 시스템 관리 작업 등을 수행하며, 시스템 부팅 시 자동으로 시작되어 지속적으로 실행된다. 데몬의 이름은 일반적으로 'd'로 끝나는 경우가 많다(e.g., `httpd`, `sshd`, `mysqld`).
### `netstat` 명령어를 사용하여 데몬 알아보기

`netstat` 명령어는 네트워크 연결, 라우팅 테이블, 인터페이스 통계 등을 표시하는 데 사용된다. 이를 통해 시스템에서 실행 중인 데몬을 확인할 수 있다. 특히, 특정 포트를 열고 있는 데몬을 확인할 때 유용하다.

```bash
# 모든 네트워크 연결과 열려 있는 포트를 표시
netstat -tuln
```

```net-tools
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      1234/httpd
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      5678/sshd
udp        0      0 0.0.0.0:123             0.0.0.0:*                           91011/ntpd
```
이 출력에서 `httpd`, `sshd`, `ntpd`와 같은 프로그램들이 데몬으로 실행 중인 것을 알 수 있다. 이들은 각각 80, 22, 123 포트를 열고 있으며, 백그라운드에서 실행되고 있다.

### 데몬이 포트에서 대기하고 자식 프로세스를 만드는 과정

1. **포트에서 대기 (Listening on a Port)**: 데몬은 특정 포트에서 클라이언트의 연결을 대기한다. 이는 일반적으로 `bind()`와 `listen()` 시스템 호출을 통해 설정된다. 예를 들어, 웹 서버 데몬인 `httpd`는 80번 포트에서 연결 요청을 대기한다.
    
2. **연결 요청 수신 (Accepting a Connection)**: 클라이언트가 데몬이 대기 중인 포트로 연결을 시도하면, 데몬은 `accept()` 시스템 호출을 사용하여 해당 연결을 수락한다. 이 단계에서 클라이언트와의 통신을 위한 새로운 소켓이 생성된다.
    
3. **자식 프로세스 생성 (Forking a Child Process)**: 데몬은 `fork()` 시스템 호출을 사용하여 자신을 복제하여 자식 프로세스를 생성한다. 자식 프로세스는 부모 프로세스의 복사본으로, 독립적인 실행 공간을 가지게 된다.
    
4. **클라이언트 요청 처리 (Handling the Client Request)**: 자식 프로세스는 클라이언트와의 통신을 담당하며, 클라이언트의 요청을 처리한다. 이 동안 부모 프로세스는 다시 대기 상태로 돌아가 새로운 연결 요청을 대기한다.
    
5. **요청 처리 완료 및 종료 (Completing the Request and Termination)**: 자식 프로세스는 클라이언트의 요청을 모두 처리한 후 종료된다. 이때 부모 프로세스는 다른 클라이언트의 연결 요청을 계속해서 처리할 수 있다.

이러한 방식으로 데몬은 다중 클라이언트의 요청을 병렬로 처리하며, 시스템의 안정성과 효율성을 높인다.

### `systemctl`을 이용한 데몬 시작 및 종료

#### 데몬 시작
데몬을 시작하려면 `systemctl start` 명령어를 사용한다.
```bash
# httpd 데몬을 시작
sudo systemctl start httpd
```
#### 데몬 종료
데몬을 종료하려면 `systemctl stop` 명령어를 사용한다.
```bash
# httpd 데몬을 종료
sudo systemctl stop httpd
```
#### 데몬의 상태 확인
데몬의 현재 상태를 확인하려면 `systemctl status` 명령어를 사용한다. 
```bash
# httpd 데몬의 상태를 확인
sudo systemctl status httpd
```
#### 데몬 재시작
데몬을 재시작하려면 `systemctl restart` 명령어를 사용한다.
```bash
# httpd 데몬을 재시작
sudo systemctl restart httpd
```

## 프로세스 관리 명령어
### `pstree` 명령어

`pstree` 명령어는 시스템에서 실행 중인 프로세스를 트리 구조로 보여주는 유틸리티이다. 각 프로세스의 부모-자식 관계를 시각적으로 쉽게 파악할 수 있게 해주며, 프로세스의 계층 구조를 이해하는 데 유용하다.

기본 사용 방법은 다음과 같다.
```bash
pstree
```

명령어를 실행하면, 아래와 같이 출력된다.
```txt
systemd─┬─NetworkManager─┬─dhclient
        │                └─2*[dnsmasq]
        ├─atd
        ├─cron
        ├─dbus-daemon
        ├─login───bash
        ├─nginx───nginx
        ├─sshd───sshd───bash───pstree
        └─udevd
```

위의 출력은 `systemd` 프로세스가 최상위 부모 프로세스로서 여러 자식 프로세스를 생성하고 있는 모습을 보여준다. 각 하위 프로세스는 부모 프로세스의 하위 항목으로 트리 구조로 표시된다.
#### 자주 사용하는 옵션
- `-p`: 각 프로세스의 PID를 함께 출력한다.
- `-u`: 각 프로세스의 사용자 이름을 함께 출력한다.
- `-a`: 명령줄 인수를 함께 출력한다.
- `-c`: 트리 구조를 압축하지 않고 전체를 보여준다.
### `ps` 명령어

`ps` 명령어는 현재 실행 중인 프로세스의 상태를 확인하는 데 사용되는 유틸리티이다. 시스템에서 어떤 프로세스가 실행 중인지, 각 프로세스의 상태, CPU 및 메모리 사용량 등을 확인할 수 있다. `ps` 명령어는 프로세스 목록을 스냅샷으로 제공하며, 지속적인 업데이트는 하지 않는다.

#### 자주 사용하는 옵션
```bash
# 시스템의 모든 프로세스를 풀 포맷으로 표시
ps -ef

# 모든 프로세스를 상세하게 표시 (BSD 스타일)
ps aux

# 특정 사용자의 프로세스를 표시
ps -u username

# 현재 터미널에서 실행 중인 프로세스를 표시
ps -f

# 현재 사용자의 프로세스를 표시
ps -u $(whoami)
```

#### `ps` 명령어의 결과값 표 윗부분의 의미
`ps` 명령어의 결과값 표에서 각 컬럼의 의미는 다음과 같다:

| 열 이름    | 의미                                   |
| ------- | ------------------------------------ |
| PID     | 프로세스 ID. 각 프로세스의 고유 식별자              |
| PPID    | 부모 프로세스 ID. 해당 프로세스를 시작한 부모 프로세스의 ID |
| USER    | 프로세스를 실행한 사용자 이름                     |
| %CPU    | 프로세스가 사용하는 CPU 사용률                   |
| %MEM    | 프로세스가 사용하는 메모리 사용률                   |
| VSZ     | 가상 메모리 사용량 (Kbytes)                  |
| RSS     | 실제 메모리 사용량 (Kbytes)                  |
| TTY     | 터미널 유형                               |
| STAT    | 프로세스 상태                              |
| START   | 프로세스가 시작된 시간이나 날짜                    |
| TIME    | 프로세스가 사용한 총 CPU 시간                   |
| COMMAND | 실행된 명령어와 그 인수                        |

`ps` 명령어를 통해 시스템의 프로세스 상태를 상세하게 확인할 수 있으며, 다양한 옵션을 통해 필요한 정보만 필터링하거나 포맷을 조정할 수 있다.

### `top` 명령어

`top` 명령어는 시스템의 실시간 프로세스 정보를 모니터링하는 데 사용한다. CPU와 메모리 사용량, 각 프로세스의 상태 등을 실시간으로 업데이트하여 표시한다.

```bash
top
```
이 명령어를 입력하면, 실시간으로 업데이트되는 시스템의 프로세스 목록과 자원 사용량을 볼 수 있다.
#### 자주 사용하는 옵션
다음은 `top` 명령어의 자주 사용하는 옵션이다:

- `-d <초>`: 업데이트 간격을 지정한다. 기본값은 3초이다.
- `-p <PID>`: 특정 PID를 모니터링한다.
- `-n <반복 횟수>`: 지정된 횟수만큼 업데이트를 수행한 후 종료한다.
- `-b`: 배치 모드로 작동한다. 표준 출력에 결과를 출력하여 스크립트나 파일에 저장할 때 유용하다.
- `-u <사용자>`: 특정 사용자의 프로세스를 필터링하여 표시한다.
- `-H`: 각 스레드를 개별적으로 표시한다.
#### `top` 명령어의 출력 정보

`top` 명령어의 출력은 두 개의 주요 섹션으로 나뉜다: 시스템 요약 정보와 프로세스 목록.
#### 시스템 요약 정보
시스템 요약 정보는 시스템의 전체 상태를 요약하여 보여준다. 여기에는 다음과 같은 정보가 포함된다:
- **uptime**: 시스템이 얼마나 오래 실행되었는지 표시한다.
- **tasks**: 현재 실행 중인, 중지된, 대기 중인 작업의 수를 나타낸다.
- **cpu(s)**: CPU의 사용률을 보여준다.
- **mem**: 물리적 메모리 사용량을 보여준다.
- **swap**: 스왑 메모리 사용량을 보여준다.
#### 프로세스 목록

각 프로세스의 상태를 나타내는 표로, 다음과 같은 열이 포함된다:

| 열 이름    | 의미                                         |
| ------- | ------------------------------------------ |
| PID     | 프로세스 ID. 각 프로세스의 고유 식별자                    |
| USER    | 프로세스를 실행한 사용자 이름                           |
| PR      | 프로세스의 우선순위                                 |
| NI      | 프로세스의 nice 값으로, 우선순위 영향을 줌                 |
| VIRT    | 가상 메모리 사용량                                 |
| RES     | 실제 메모리 사용량                                 |
| SHR     | 공유 메모리 사용량                                 |
| S       | 프로세스의 현재 상태 (e.g., S=sleeping, R=running). |
| %CPU    | 프로세스가 사용하는 CPU 사용률                         |
| %MEM    | 프로세스가 사용하는 메모리 사용률                         |
| TIME+   | 프로세스가 사용한 총 CPU 시간                         |
| COMMAND | 실행된 명령어와 그 인수                              |

### `exec` 명령어
`exec` 명령어는 현재 쉘 프로세스를 대체하여 지정된 명령어를 실행하는 데 사용된다. 이는 새로운 프로세스를 생성하지 않고, 현재 프로세스 공간에서 직접 명령어를 실행한다는 점에서 다른 명령어 실행 방식과 다르다. 즉, `exec`를 사용하면 명령어가 실행된 후에는 원래의 쉘로 돌아오지 않는다.

사용 방법
```bash
exec <명령어> [인수 ..]
```

예시 :
```bash
# 현재 쉘을 /bin/bash로 대체
exec /bin/bash

# 현재 쉘을 ls -l 명령어로 대체 (실행 후 쉘이 종료됨)
exec ls -l
```

# Chapter.11 디스크 관리
## 파일 시스템
### 파일 시스템이란 무엇인가?
파일 시스템(File System)은 운영 체제가 데이터를 저장하고, 관리하며, 접근하는 구조와 방식을 제공하는 시스템 소프트웨어의 일부분이다. 파일 시스템은 데이터를 파일이라는 단위로 저장하고, 이러한 파일들을 디렉토리 구조로 구성하여 체계적으로 관리한다. 이는 데이터의 저장, 검색, 수정, 삭제 등을 효율적으로 수행할 수 있도록 도와준다.
### 파일 시스템의 종류
#### 1. **MINIX 파일 시스템**

- **설명**: MINIX 파일 시스템은 교육 목적으로 설계된 MINIX 운영 체제에서 사용되는 파일 시스템이다. 간단하고 안정적이며, 디스크 공간을 효율적으로 사용하지만, 대용량 디스크를 지원하지 않는다.
- **특징**: 64MB의 최대 파일 시스템 크기, 30문자 파일 이름 제한, 단순한 구조.

#### 2. **EXT (Extended File System)**

- **설명**: EXT 파일 시스템은 리눅스에서 처음 도입된 파일 시스템으로, ext2, ext3, ext4로 발전해 왔다.
- **특징**:
    - **ext2**: 저널링을 지원하지 않으며, 안정적이고 성능이 우수하다.
    - **ext3**: ext2에 저널링 기능이 추가되어 데이터 손실 가능성을 줄였다.
    - **ext4**: ext3의 성능을 개선하고, 대용량 파일과 파일 시스템을 지원한다.

#### 3. **ReiserFS**

- **설명**: 고성능 저널링 파일 시스템으로, 작은 파일 처리에 최적화되어 있다.
- **특징**: 효율적인 공간 사용, 빠른 파일 액세스, 고급 디스크 구조.

#### 4. **XFS**

- **설명**: SGI에서 개발한 고성능 파일 시스템으로, 대용량 파일과 높은 처리량을 지원한다.
- **특징**: 확장성, 신뢰성, 빠른 파일 시스템 복구, 대용량 파일 처리에 최적화.

#### 5. **Btrfs (B-Tree File System)**

- **설명**: 현대적인 리눅스 파일 시스템으로, 데이터 무결성, 스냅샷, RAID 지원 등을 제공한다.
- **특징**: 고급 기능, 효율적인 스토리지 관리, 스냅샷 및 복제 기능.

#### 6. **FAT (File Allocation Table)**

- **설명**: MS-DOS와 윈도우에서 널리 사용된 파일 시스템으로, 이동식 저장 장치에 자주 사용된다.
- **특징**: 광범위한 호환성, 단순한 구조, 대용량 파일 지원 제한.

#### 7. **NTFS (New Technology File System)**

- **설명**: 마이크로소프트의 파일 시스템으로, 윈도우 NT 계열 운영 체제에서 사용된다.
- **특징**: 보안 기능, 대용량 파일 및 볼륨 지원, 데이터 압축, 암호화 지원.

### `mkfs` 명령어
`mkfs` (Make File System) 명령어는 디스크에 파일 시스템을 생성하는 데 사용된다. 여러 파일 시스템 유형을 지원하며, 특정 파일 시스템에 따라 다양한 옵션을 제공한다.
### 주요 옵션
- `-t` (type): 생성할 파일 시스템의 유형을 지정한다. (예: `ext4`, `xfs`, `vfat`)
- `-L` (label): 파일 시스템 레이블을 설정한다.
- `-b` (block-size): 파일 시스템 블록 크기를 지정한다.

```bash
# 디스크 /dev/sdX1에 ext4 파일 시스템 생성
mkfs.ext4 /dev/sdX1

# 디스크 /dev/sdX1에 ext4 파일 시스템 생성 및 레이블 설정
mkfs.ext4 -L my_label /dev/sdX1

# 디스크 /dev/sdX1에 xfs 파일 시스템 생성
mkfs.xfs /dev/sdX1

# 디스크 /dev/sdX1에 vfat 파일 시스템 생성
mkfs.vfat /dev/sdX1
```

## 그놈 디스크 관리도구(Gnome-disks)
### GNOME 디스크 관리도구
GNOME 디스크 관리도구(Disks, 이전 이름: GNOME Disk Utility)는 GNOME 데스크톱 환경에서 제공하는 디스크 관리 소프트웨어이다. 이 도구는 사용자가 하드 드라이브, SSD, USB 드라이브 등 다양한 저장 장치를 쉽게 관리할 수 있도록 돕는다. 직관적인 그래픽 사용자 인터페이스(GUI)를 제공하여 복잡한 명령어 없이도 다양한 디스크 관리 작업을 수행할 수 있다.

GUI 환경이라면 프로그램 > 유틸리티 > 디스크로 접속한다. 또는, 콘솔 창에서 아래 명령어를 입력한다.
```bash
gnome-disks
```
#### 주요 기능
1. **디스크 벤치마킹![[스크린샷 2024-07-29 오후 10.58.47.png]]**
    - 디스크의 읽기 및 쓰기 성능을 측정하여 벤치마크 테스트를 수행할 수 있다.
    - 디스크 성능을 평가하고 비교할 수 있다.
2. **SMART 데이터 확인 및 자체 검사![[스크린샷 2024-07-29 오후 10.59.49.png]]**
    - SMART(Self-Monitoring, Analysis, and Reporting Technology) 상태를 확인하여 디스크의 건강 상태를 모니터링할 수 있다.
    - 디스크 오류를 사전에 감지하고, 성능을 평가할 수 있다.
3. **드라이브 설정![[스크린샷 2024-07-29 오후 11.00.34.png]]
    - 디스크의 기본 설정을 관리할 수 있다.
    - 디스크 이름 변경, 쓰기 캐시 설정 등 다양한 옵션을 제공한다.
4. **파티션 만들기/포맷
   ![[스크린샷 2024-07-29 오후 11.00.49.png]]![[스크린샷 2024-07-29 오후 11.00.58.png]]**
    - 디스크 파티션을 생성, 삭제, 크기 조정, 포맷할 수 있다.
    - 파티션 테이블을 관리하고, 파티션에 파일 시스템을 적용할 수 있다.
5. **파티션 편집**
    - 기존 파티션의 크기를 조정하거나 삭제할 수 있다.
    - 파티션 레이블을 변경할 수 있다.
6. **파일 시스템 편집**
    - 파일 시스템을 변경하거나 조정할 수 있다.
    - 파일 시스템을 검사하고 수정할 수 있다.
7. **마운트 옵션**
    - 디스크와 파티션의 마운트 옵션을 설정할 수 있다.
    - 자동 마운트 설정을 관리하여 시스템 부팅 시 디스크가 자동으로 마운트되도록 설정할 수 있다.
8. **마운트**
    - 디스크와 파티션을 마운트하거나 언마운트할 수 있다.
9. **마운트 확인(`df` 명령어)**
   ```bash
   # df 명령어를 사용하여 현재 마운트된 파일 시스템과 사용량을 확인
df -h
```

출력 예시
```txt
Filesystem      Size  Used Avail Use% Mounted on
udev            1.9G     0  1.9G   0% /dev
tmpfs           396M  1.4M  394M   1% /run
/dev/sda1        50G   12G   35G  25% /
tmpfs           2.0G  160K  2.0G   1% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup
/dev/sda2       100G   25G   70G  27% /home
```

## 디스크 관리 명령어
### 물리 볼륨, 파티션, 논리 볼륨, 마운트의 개념![[image.png]]
#### 물리 볼륨 (Physical Volume)
물리 볼륨은 실제 디스크나 디스크의 파티션을 의미한다. 이는 물리적인 저장 장치의 일부분으로, 논리 볼륨 관리(LVM)에서 가장 기본이 되는 단위이다. 물리 볼륨은 하나 이상의 논리 볼륨을 생성하기 위한 공간을 제공한다.
#### 파티션 (Partition)
파티션은 물리적 디스크를 여러 개의 논리적 구획으로 나눈 것이다. 각 파티션은 독립된 파일 시스템을 가질 수 있으며, 운영 체제에서 별도의 디스크 드라이브로 인식된다. 파티션을 통해 디스크 공간을 효율적으로 관리하고, 데이터와 시스템 파일을 분리할 수 있다.
#### 논리 볼륨 (Logical Volume)
논리 볼륨은 LVM에서 제공하는 기능으로, 여러 물리 볼륨을 하나의 논리적인 저장 공간으로 묶어 관리할 수 있다. 논리 볼륨은 유연한 디스크 공간 관리와 동적 크기 조정을 가능하게 하며, 물리적인 디스크 구조와는 독립적으로 운영된다.
#### 마운트 (Mount)
마운트는 파일 시스템을 특정 디렉토리에 연결하여 사용자가 접근할 수 있게 하는 과정이다. 마운트 지점은 디렉토리로, 파일 시스템이 마운트되면 해당 디렉토리 아래에서 파일 시스템의 내용에 접근할 수 있다. 마운트는 파일 시스템이 실제 사용되기 위해 필요한 단계이다.

### `df` 명령어

`df` (Disk Free) 명령어는 파일 시스템의 디스크 사용량과 남은 용량을 확인하는 데 사용된다. 이 명령어는 현재 마운트된 파일 시스템의 디스크 공간 사용 상태를 요약하여 보여준다. 주로 시스템 관리자가 디스크 공간을 모니터링하고 관리하는 데 유용하다.
### 주요 옵션
- `-h` (Human-readable): 사람이 읽기 쉬운 형식으로 출력한다. 즉, KB, MB, GB 등의 단위로 표시한다.
- `-a` (All): 사용되지 않는 파일 시스템까지 모든 파일 시스템의 정보를 출력한다.
- `-T` (Print file system type): 각 파일 시스템의 유형을 함께 출력한다.
- `-i` (Inodes): 디스크 사용량 대신 i-node 사용량을 출력한다.
- `--total`: 모든 파일 시스템의 총 사용량을 마지막 줄에 합산하여 출력한다.

```bash
# 모든 파일 시스템의 디스크 사용량을 사람이 읽기 쉬운 형식으로 출력
df -h

# 사용되지 않는 파일 시스템을 포함한 모든 파일 시스템의 디스크 사용량을 출력
df -a

# 파일 시스템 유형을 포함하여 디스크 사용량을 출력
df -T

# i-node 사용량을 출력
df -i

# 모든 파일 시스템의 총 사용량을 합산하여 출력
df --total
```

### `mount` 명령어
`mount` 명령어는 파일 시스템을 특정 디렉토리에 연결하여 사용자가 접근할 수 있게 하는 데 사용된다. 마운트된 파일 시스템은 마운트 지점으로 지정된 디렉토리에서 액세스할 수 있다.
### 주요 옵션
- `-t` (type): 마운트할 파일 시스템의 유형을 지정한다.
- `-o` (options): 마운트 시 사용할 추가 옵션을 지정한다. 예: `ro`(읽기 전용), `rw`(읽기/쓰기), `noexec`(실행 불가).
- `-a` (all): `/etc/fstab` 파일에 나열된 모든 파일 시스템을 마운트한다.
- `-r` (readonly): 파일 시스템을 읽기 전용으로 마운트한다.
- `-v` (verbose): 마운트 과정의 상세 정보를 출력한다.

```bash
# 기본 사용법: 파일 시스템을 /mnt 디렉토리에 마운트
mount /dev/sdX1 /mnt

# 파일 시스템 유형을 지정하여 마운트
mount -t ext4 /dev/sdX1 /mnt

# 읽기 전용으로 마운트
mount -o ro /dev/sdX1 /mnt

# /etc/fstab 파일에 나열된 모든 파일 시스템을 마운트
mount -a

# 마운트 과정의 상세 정보를 출력
mount -v /dev/sdX1 /mnt
```

### `umount` 명령어
`umount` 명령어는 마운트된 파일 시스템을 해제하는 데 사용된다. 파일 시스템이 언마운트되면 해당 디렉토리에서 더 이상 액세스할 수 없게 된다.
### 주요 옵션
- `-a` (all): `/etc/mtab` 파일에 나열된 모든 파일 시스템을 언마운트한다.
- `-f` (force): 강제로 언마운트한다. 주로 NFS 같은 네트워크 파일 시스템에서 유용하다.
- `-l` (lazy): 현재 사용 중인 파일 시스템을 나중에 안전하게 언마운트할 수 있게 지연 언마운트를 수행한다.
- `-v` (verbose): 언마운트 과정의 상세 정보를 출력한다.

```bash
# 기본 사용법: /mnt 디렉토리에서 파일 시스템 언마운트
umount /mnt

# 강제로 파일 시스템 언마운트
umount -f /mnt

# 모든 파일 시스템을 언마운트
umount -a

# 지연 언마운트
umount -l /mnt

# 언마운트 과정의 상세 정보를 출력
umount -v /mnt
```

### `parted` 명령어
`parted` 명령어는 디스크 파티션을 관리하는 데 사용된다. 파티션을 생성, 삭제, 크기 조정, 복사할 수 있으며, GPT와 MBR 파티션 테이블을 모두 지원한다.
### 주요 옵션
- `mklabel`: 새로운 파티션 테이블을 생성한다. (예: `gpt`, `msdos`)
- `mkpart`: 새로운 파티션을 생성한다.
- `rm`: 파티션을 삭제한다.
- `resizepart`: 파티션 크기를 조정한다.
- `print`: 현재 디스크의 파티션 테이블을 출력한다.

```bash
# 디스크 /dev/sdX에서 새로운 GPT 파티션 테이블을 생성
parted /dev/sdX mklabel gpt

# 디스크 /dev/sdX에서 새로운 파티션 생성 (시작 1MiB, 끝 10GiB)
parted /dev/sdX mkpart primary 1MiB 10GiB

# 디스크 /dev/sdX의 파티션 1을 삭제
parted /dev/sdX rm 1

# 디스크 /dev/sdX의 파티션 1 크기를 20GiB로 조정
parted /dev/sdX resizepart 1 20GiB

# 디스크 /dev/sdX의 파티션 테이블 출력
parted /dev/sdX print
```

### `du` 명령어
`du` (Disk Usage) 명령어는 파일이나 디렉토리의 디스크 사용량을 확인하는 데 사용된다. 이 명령어는 각 파일과 디렉토리가 차지하는 디스크 공간을 표시하여, 사용자가 시스템의 디스크 사용 현황을 파악할 수 있게 도와준다.
### 주요 옵션
- `-h` (human-readable): 사람이 읽기 쉬운 형식으로 출력한다. 즉, KB, MB, GB 등의 단위로 표시한다.
- `-s` (summarize): 각 인수의 총 디스크 사용량만 출력한다.
- `-a` (all): 디렉토리뿐만 아니라 모든 파일의 디스크 사용량도 출력한다.
- `-c` (total): 결과의 마지막에 총계를 추가로 출력한다.
- `-d <depth>`: 디렉토리 깊이를 지정하여, 지정한 깊이만큼의 디렉토리 사용량을 출력한다.
- `-x` (one-file-system): 현재 파일 시스템 내의 파일만 계산한다.
- `--max-depth=N`: 지정한 깊이까지만 디스크 사용량을 표시한다.
- `--time`: 각 파일의 마지막 수정 시간을 출력한다.

```bash
# 현재 디렉토리와 하위 디렉토리의 디스크 사용량을 사람이 읽기 쉬운 형식으로 출력
du -h

# 현재 디렉토리의 총 디스크 사용량만 출력
du -sh

# 현재 디렉토리와 모든 파일의 디스크 사용량을 사람이 읽기 쉬운 형식으로 출력
du -ah

# 현재 디렉토리와 하위 디렉토리의 디스크 사용량을 사람이 읽기 쉬운 형식으로 출력하고, 총계를 추가로 출력
du -ch

# 현재 디렉토리와 하위 디렉토리의 디스크 사용량을 깊이 1까지만 출력
du -d 1 -h

# 현재 파일 시스템 내의 파일만 계산
du -x

# 현재 디렉토리와 하위 디렉토리의 디스크 사용량을 깊이 2까지만 출력
du --max-depth=2 -h

# 현재 디렉토리와 하위 디렉토리의 디스크 사용량과 각 파일의 마지막 수정 시간을 출력
du --time -h
```

### `pvs`, `vgs`, `lvs` 명령어

`pvs`, `vgs`, `lvs`는 각각 물리 볼륨(Physical Volumes), 볼륨 그룹(Volume Groups), 논리 볼륨(Logical Volumes)의 정보를 표시하는 LVM(Logical Volume Manager) 명령어이다. 이 명령어들은 시스템의 스토리지 구성 요소를 모니터링하고 관리하는 데 유용하다.
#### `pvs` 명령어
`pvs` 명령어는 시스템에 존재하는 모든 물리 볼륨의 정보를 표시한다. 이는 물리 디스크 또는 디스크 파티션으로, LVM 볼륨 그룹의 기본 구성 요소이다.
##### 주요 옵션
- `-a` 또는 `--all`: 모든 물리 볼륨을 표시한다.
- `-o` 또는 `--options`: 출력할 컬럼을 지정한다.
- `-v` 또는 `--verbose`: 상세 정보를 출력한다.
```bash
# 시스템의 모든 물리 볼륨을 기본 형식으로 표시
pvs

# 모든 물리 볼륨을 상세하게 표시
pvs -v

# 특정 컬럼을 지정하여 물리 볼륨 정보를 표시
pvs -o +lv_name
```
#### `vgs` 명령어
`vgs` 명령어는 시스템에 존재하는 모든 볼륨 그룹의 정보를 표시한다. 볼륨 그룹은 하나 이상의 물리 볼륨으로 구성되며, 논리 볼륨을 생성하는 데 사용된다.
```bash
# 시스템의 모든 볼륨 그룹을 기본 형식으로 표시
vgs

# 모든 볼륨 그룹을 상세하게 표시
vgs -v

# 특정 컬럼을 지정하여 볼륨 그룹 정보를 표시
vgs -o +pv_name
```
##### 주요 옵션
- `-a` 또는 `--all`: 모든 볼륨 그룹을 표시한다.
- `-o` 또는 `--options`: 출력할 컬럼을 지정한다.
- `-v` 또는 `--verbose`: 상세 정보를 출력한다.

#### `lvs` 명령어
`lvs` 명령어는 시스템에 존재하는 모든 논리 볼륨의 정보를 표시한다. 논리 볼륨은 볼륨 그룹 내에서 생성되며, 실제 데이터가 저장되는 공간이다.
##### 주요 옵션
- `-a` 또는 `--all`: 모든 논리 볼륨을 표시한다.
- `-o` 또는 `--options`: 출력할 컬럼을 지정한다.
- `-v` 또는 `--verbose`: 상세 정보를 출력한다.
```bash
# 시스템의 모든 논리 볼륨을 기본 형식으로 표시
lvs

# 모든 논리 볼륨을 상세하게 표시
lvs -v

# 특정 컬럼을 지정하여 논리 볼륨 정보를 표시
lvs -o +vg_name
```
### `ssm` 명령어

`ssm` (System Storage Manager) 명령어는 다양한 스토리지 기기를 관리할 수 있는 통합 인터페이스를 제공하는 유틸리티이다. 이를 통해 디스크, 파티션, 볼륨 그룹 및 논리 볼륨을 쉽게 관리할 수 있다.

```bash
# 시스템의 스토리지 장치, 볼륨 그룹 및 논리 볼륨을 나열
ssm list

# 새로운 논리 볼륨 생성 (크기: 10GB, 이름: mylv, 볼륨 그룹: myvg)
ssm create -s 10G -n mylv myvg

# 기존 논리 볼륨 크기 조정 (크기: 20GB, 이름: mylv, 볼륨 그룹: myvg)
ssm resize -s 20G /dev/myvg/mylv

# 논리 볼륨 삭제 (이름: mylv, 볼륨 그룹: myvg)
ssm remove /dev/myvg/mylv

# 새로운 볼륨 그룹 생성 (이름: myvg, 디스크: /dev/sdb1)
ssm add /dev/sdb1 --vg myvg
```

### `lvm` 명령어

`lvm` (Logical Volume Manager) 명령어는 논리 볼륨 관리자를 통해 디스크와 파티션을 논리적으로 관리할 수 있게 해주는 유틸리티이다. 이를 통해 디스크 공간을 동적으로 할당하고, 크기를 조정할 수 있다.

```bash
# 새로운 물리 볼륨 생성 (디스크: /dev/sdb1)
pvcreate /dev/sdb1

# 새로운 볼륨 그룹 생성 (이름: myvg, 물리 볼륨: /dev/sdb1)
vgcreate myvg /dev/sdb1

# 새로운 논리 볼륨 생성 (크기: 10GB, 이름: mylv, 볼륨 그룹: myvg)
lvcreate -L 10G -n mylv myvg

# 논리 볼륨 크기 조정 (크기: 20GB, 이름: mylv, 볼륨 그룹: myvg)
lvresize -L 20G /dev/myvg/mylv

# 논리 볼륨 삭제 (이름: mylv, 볼륨 그룹: myvg)
lvremove /dev/myvg/mylv
```
### 스왑(Swap)
#### 스왑이란?
스왑(Swap)은 물리적 메모리(RAM)가 부족할 때, 디스크의 일부 공간을 가상 메모리로 사용하도록 하는 메모리 관리 기법이다. 스왑 공간은 메모리 부족 상황에서 프로그램을 계속 실행할 수 있도록 지원하며, 시스템의 안정성과 성능을 유지하는 데 중요한 역할을 한다.
#### 스왑의 주요 기능
1. **메모리 확장**: 물리적 메모리가 모두 사용된 경우, 스왑 공간을 사용하여 추가 메모리 용량을 확보할 수 있다.
2. **시스템 안정성**: 메모리 부족으로 인해 시스템이 중단되지 않도록 도와준다.
3. **프로세스 관리**: 사용되지 않는 프로세스의 메모리를 스왑 공간으로 옮겨 물리적 메모리를 더 효율적으로 사용할 수 있게 한다.
#### 스왑의 단점
1. **속도 저하**: 디스크는 RAM보다 속도가 느리기 때문에, 스왑 공간을 사용하면 시스템 성능이 저하될 수 있다.
2. **디스크 사용량 증가**: 스왑 공간을 사용하면 디스크 사용량이 증가하게 된다.
### `mkswap` 명령어
`mkswap` 명령어는 디스크의 특정 파티션을 스왑 공간으로 초기화하는 데 사용된다. 이는 스왑 공간을 생성하는 과정의 일부이며, 이후 `swapon` 명령어를 사용하여 스왑 공간을 활성화할 수 있다.
#### 주요 옵션
- `-L` (label): 스왑 영역에 레이블을 설정한다.
- `-v` (verbose): 자세한 출력을 제공한다.

```bash
# 디스크의 /dev/sdX2 파티션을 스왑 공간으로 초기화
mkswap /dev/sdX2

# 디스크의 /dev/sdX2 파티션을 스왑 공간으로 초기화하고, 레이블을 설정
mkswap -L swap_space /dev/sdX2

# 디스크의 /dev/sdX2 파티션을 스왑 공간으로 초기화하고, 자세한 출력을 제공
mkswap -v /dev/sdX2
```

위 명령어를 사용하여 스왑 공간을 설정한 후, `swapon` 명령어로 스왑 공간을 활성화할 수 있다:
```bash
# 스왑 공간 활성화
swapon /dev/sdX2
```
이와 같이 `mkswap` 명령어는 시스템의 가상 메모리 관리에 필수적인 스왑 공간을 초기화하는 데 사용된다.

# Chapter.12 소프트웨어 관리
## 소프트웨어 관리 패키지
### `yum`(Yellowdog Updater Modified) 명령어

`yum` (Yellowdog Updater, Modified)은 RPM 기반 패키지 관리 시스템을 사용하는 리눅스 배포판에서 소프트웨어 패키지를 관리하기 위한 명령어이다. `yum`은 패키지의 설치, 업데이트, 제거, 검색, 정보 조회 등을 간편하게 수행할 수 있도록 도와준다. 주로 CentOS, RHEL, Fedora 등의 배포판에서 사용된다.

```bash
# 패키지를 설치
yum install <패키지명>

# 패키지를 제거
yum remove <패키지명>

# 특정 패키지를 업데이트
yum update <패키지명>

# 시스템의 모든 패키지를 업데이트
yum update

# 패키지를 검색
yum search <패키지명>

# 패키지의 상세 정보를 조회
yum info <패키지명>

# 패키지 그룹을 설치
yum groupinstall "<그룹명>"

# 패키지 그룹을 제거
yum groupremove "<그룹명>"

# 패키지와 캐시를 정리
yum clean all

# 특정 리포지터리를 활성화하여 패키지 설치
yum --enablerepo=<리포지터리명> install <패키지명>

# 특정 리포지터리를 비활성화하여 패키지 설치
yum --disablerepo=<리포지터리명> install <패키지명>
```

### `apt`(Advanced Package Tool) 명령어

`apt` (Advanced Package Tool)는 Debian 기반 리눅스 배포판에서 소프트웨어 패키지를 관리하기 위한 명령어이다. `apt`는 패키지의 설치, 업데이트, 제거, 검색, 정보 조회 등을 간편하게 수행할 수 있도록 도와준다. 주로 Ubuntu, Debian 등의 배포판에서 사용된다.

```bash
# 패키지를 설치
apt install <패키지명>

# 패키지를 제거
apt remove <패키지명>

# 패키지를 설정 파일과 함께 완전히 제거
apt purge <패키지명>

# 특정 패키지를 업데이트
apt upgrade <패키지명>

# 시스템의 모든 패키지를 업데이트
apt upgrade

# 패키지를 검색
apt search <패키지명>

# 패키지의 상세 정보를 조회
apt show <패키지명>

# 패키지 목록을 업데이트
apt update

# 사용하지 않는 패키지를 자동 제거
apt autoremove

# 다운로드한 패키지 파일과 캐시를 정리
apt clean
```

### RPM 패키지 관리자

RPM 패키지 관리자(RPM Package Manager)는 레드햇 계열의 리눅스 배포판에서 사용되는 패키지 관리 시스템이다. RPM은 소프트웨어 패키지의 설치, 업그레이드, 제거 및 쿼리 기능을 제공하며, `.rpm` 확장자를 가진 파일로 패키지를 배포한다. 주로 CentOS, Fedora, RHEL(Red Hat Enterprise Linux) 등에서 사용된다.

```bash
# 패키지 설치
# example.rpm 파일을 설치한다.
rpm -ivh example.rpm

# 패키지 업그레이드
# example.rpm 파일을 사용하여 기존 패키지를 업그레이드한다.
rpm -Uvh example.rpm

# 패키지 제거
# example 패키지를 시스템에서 제거한다.
rpm -e example

# 패키지 정보 조회
# example 패키지의 정보를 출력한다.
rpm -qi example

# 패키지 파일 목록 조회
# example 패키지의 파일 목록을 출력한다.
rpm -ql example

# 특정 파일이 어느 패키지에 속하는지 조회
# /usr/bin/example 파일이 속한 패키지를 출력한다.
rpm -qf /usr/bin/example

# 설치된 모든 패키지 목록 조회
# 시스템에 설치된 모든 패키지를 출력한다.
rpm -qa

# 패키지 검증
# example 패키지의 무결성을 검증한다.
rpm -V example
```

### `make`와 `make install`
`make`와 `make install` 명령어는 소스 코드로부터 소프트웨어를 빌드하고 설치하는 데 사용된다. 이 과정은 일반적으로 소스 코드 디렉토리 내에서 이루어지며, `Makefile`이라는 파일에 정의된 지침을 따른다.
#### 기본 개념
- **`make`**: `Makefile`을 읽고, 소스 코드를 컴파일하여 실행 파일이나 라이브러리를 생성한다.
- **`make install`**: `make`로 빌드된 파일들을 시스템의 적절한 위치에 설치한다. 예를 들어, 실행 파일은 `/usr/local/bin`에, 라이브러리는 `/usr/local/lib`에 설치된다.  
#### 예시
##### 준비 작업

1. **소스 코드 다운로드**: 소프트웨어의 소스 코드를 다운로드한다.

```sh

wget http://example.com/software-1.0.tar.gz

```

2. **압축 해제**: 다운로드한 소스 코드를 압축 해제한다.

```sh

tar -xzvf software-1.0.tar.gz

cd software-1.0

```
##### 소프트웨어 빌드 및 설치

1. **`configure` 스크립트 실행**: 소프트웨어의 환경을 설정한다. 이 단계는 `Makefile`을 생성한다.

```sh

./configure

```
2. **`make` 명령어 실행**: 소스 코드를 컴파일한다.

```sh

make

```
3. **`make install` 명령어 실행**: 컴파일된 파일을 시스템에 설치한다.

```sh

sudo make install

```
#### 각 단계의 상세 설명
##### 1. `configure`
`configure` 스크립트는 시스템 환경을 검사하고, 소프트웨어 빌드를 위한 환경을 설정한다. 이 단계에서는 필요한 라이브러리와 헤더 파일이 있는지 확인하고, 최종적으로 `Makefile`을 생성한다.
```sh

./configure

```

출력 예시:
```sh

checking for gcc... gcc

checking for C compiler default output file name... a.out

checking whether the C compiler works... yes

...

config.status: creating Makefile

```
##### 2. `make`

`make` 명령어는 `Makefile`을 읽고, 소스 코드를 컴파일하여 실행 파일을 생성한다. `Makefile`에는 빌드 과정에서 필요한 모든 지침이 포함되어 있다.
```sh

make

```

출력 예시:
```sh

gcc -o main.o -c main.c

gcc -o utils.o -c utils.c

gcc -o software main.o utils.o

```
##### 3. `make install`
`make install` 명령어는 컴파일된 실행 파일과 라이브러리를 시스템의 적절한 위치에 복사한다. 이 과정에서는 일반적으로 루트 권한이 필요하므로 `sudo`를 사용한다.
```sh

sudo make install

```

출력 예시:
```sh

[sudo] password for user:

install -m 755 software /usr/local/bin/software

install -m 644 libsoftware.a /usr/local/lib/libsoftware.a

```
#### 정리
`make`와 `make install` 과정은 소프트웨어를 소스 코드로부터 빌드하고 설치하는 표준적인 방법이다. 이 과정은 다음과 같은 순서로 진행된다:

1. `configure` 스크립트를 실행하여 환경 설정 및 `Makefile` 생성
2. `make` 명령어를 실행하여 소스 코드를 컴파일
3. `make install` 명령어를 실행하여 컴파일된 파일을 시스템에 설치

# Chapter.13 네트워크 보안설정
## Firewalld
### `firewalld`에 대하여

`firewalld`는 리눅스에서 방화벽을 관리하는 데 사용되는 동적 방화벽 관리 도구이다. 이는 iptables와 같은 기존 방화벽 도구의 복잡성을 줄이고, 더 쉽게 방화벽 규칙을 설정하고 관리할 수 있도록 설계되었다. `firewalld`는 주로 레드햇 계열의 배포판(CentOS, Fedora, RHEL 등)에서 사용된다.
### 주요 개념
1. **영역(Zones)**: `firewalld`는 네트워크 인터페이스와 트래픽을 관리하기 위해 영역이라는 개념을 사용한다. 각 영역은 특정 트래픽에 대해 서로 다른 방화벽 규칙을 가지고 있다. 영역을 통해 네트워크의 다른 부분에 대해 다른 보안 수준을 적용할 수 있다.
2. **서비스(Services)**: `firewalld`는 미리 정의된 서비스 목록을 사용하여 특정 포트와 프로토콜에 대한 방화벽 규칙을 쉽게 설정할 수 있다. 예를 들어, `http`, `https`, `ssh`와 같은 서비스가 있다.
3. **영구적 설정과 일시적 설정**: `firewalld`는 두 가지 유형의 설정을 지원한다. 일시적 설정은 시스템 재부팅 시 사라지며, 영구적 설정은 재부팅 후에도 유지된다.

### 주요 명령어 및 예시
#### `firewalld` 시작, 중지 및 상태 확인
```bash
# firewalld 시작
sudo systemctl start firewalld

# firewalld 중지
sudo systemctl stop firewalld

# firewalld 상태 확인
sudo systemctl status firewalld

# firewalld 재시작
sudo systemctl restart firewalld

# firewalld 부팅 시 자동 시작 설정
sudo systemctl enable firewalld

# firewalld 부팅 시 자동 시작 해제
sudo systemctl disable firewalld
```

#### 영역(Zones) 관리
영역은 `firewalld`의 핵심 구성 요소로, 각 영역에는 특정 트래픽을 허용하거나 차단하는 규칙이 정의되어 있다.
###### 영역(Zones) 종류
- **drop**: 모든 수신 트래픽을 차단하며, 응답이 없는 상태로 유지한다.
- **block**: 모든 수신 트래픽을 차단하며, "주소 도달 불가" 응답을 보낸다.
- **public**: 공용 네트워크에 사용되며, 제한된 수신 트래픽만 허용한다.
- **external**: 외부 네트워크와의 연결에 사용되며, NAT를 사용한다.
- **dmz**: DMZ에 위치한 시스템에 사용되며, 선택된 트래픽만 허용한다.
- **work**: 업무 네트워크에 사용되며, 더 많은 수신 트래픽을 허용한다.
- **home**: 가정 네트워크에 사용되며, 대부분의 수신 트래픽을 허용한다.
- **internal**: 내부 네트워크에 사용되며, 대부분의 수신 트래픽을 허용한다.
- **trusted**: 모든 수신 트래픽을 허용한다.

이러한 영역을 통해 `firewalld`는 네트워크의 다른 부분에 대해 다양한 보안 정책을 적용할 수 있다.
```bash
# 사용 가능한 모든 영역 목록 보기
sudo firewall-cmd --get-zones

# 활성화된 영역 확인
sudo firewall-cmd --get-active-zones

# 특정 인터페이스가 할당된 영역 확인
sudo firewall-cmd --get-zone-of-interface=eth0

# 기본 영역 설정
sudo firewall-cmd --set-default-zone=public

# 영역의 상세 정보 보기
sudo firewall-cmd --zone=public --list-all
```
#### 서비스(Services) 관리
`firewalld`는 미리 정의된 서비스 목록을 사용하여 특정 포트와 프로토콜에 대한 방화벽 규칙을 쉽게 설정할 수 있다.
```bash
# 서비스 추가 (일시적)
sudo firewall-cmd --zone=public --add-service=http

# 서비스 추가 (영구적)
sudo firewall-cmd --zone=public --add-service=http --permanent

# 서비스 제거 (일시적)
sudo firewall-cmd --zone=public --remove-service=http

# 서비스 제거 (영구적)
sudo firewall-cmd --zone=public --remove-service=http --permanent

# 변경 사항 적용
sudo firewall-cmd --reload
```
#### 포트(Ports) 관리
특정 포트를 열거나 닫는 방법이다.
```bash
# 포트 추가 (일시적)
sudo firewall-cmd --zone=public --add-port=8080/tcp

# 포트 추가 (영구적)
sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent

# 포트 제거 (일시적)
sudo firewall-cmd --zone=public --remove-port=8080/tcp

# 포트 제거 (영구적)
sudo firewall-cmd --zone=public --remove-port=8080/tcp --permanent

# 변경 사항 적용
sudo firewall-cmd --reload
```
#### 인터페이스(Interfaces) 관리
네트워크 인터페이스를 특정 영역에 할당하여 관리할 수 있다. (이더넷, 무선, 가상 네트워크를 조작하는 과정이다.)
```bash
# 인터페이스를 특정 영역에 추가 (일시적) (보통 eth : 이더넷, wlan : 무선, veth : 가상)
sudo firewall-cmd --zone=public --change-interface=eth0

# 인터페이스를 특정 영역에 추가 (영구적)
sudo firewall-cmd --zone=public --add-interface=eth0 --permanent

# 인터페이스를 특정 영역에서 제거 (영구적)
sudo firewall-cmd --zone=public --remove-interface=eth0 --permanent

# 변경 사항 적용
sudo firewall-cmd --reload
```

### `firewalld` 포트 포워딩 설정

포트 포워딩은 외부에서 들어오는 트래픽을 특정 포트로 리디렉션하여 내부 네트워크의 다른 포트나 호스트로 전달하는 기능이다. `firewalld`를 사용하여 포트 포워딩을 설정할 수 있다. 이를 위해서는 `firewalld`의 `--add-forward-port` 옵션을 사용한다.
#### 포트 포워딩 설정 예시
예를 들어, 외부에서 들어오는 TCP 트래픽을 포트 8080으로 받아 내부의 포트 80으로 포워딩하고자 할 때의 설정 방법은 다음과 같다:
```bash
# 외부에서 들어오는 TCP 트래픽을 포트 8080으로 받아 내부의 포트 80으로 포워딩 (일시적)
sudo firewall-cmd --zone=public --add-forward-port=port=8080:proto=tcp:toport=80

# 외부에서 들어오는 TCP 트래픽을 포트 8080으로 받아 내부의 포트 80으로 포워딩 (영구적)
sudo firewall-cmd --zone=public --add-forward-port=port=8080:proto=tcp:toport=80 --permanent

# 변경 사항 적용
sudo firewall-cmd --reload
```
위 명령어에서 사용된 각 옵션의 의미는 다음과 같다:
- `--zone=public`: 포트 포워딩을 설정할 영역을 지정한다.
- `--add-forward-port=port=8080:proto=tcp:toport=80`: 포트 8080으로 들어오는 TCP 트래픽을 포트 80으로 포워딩한다.
- `--permanent`: 설정을 영구적으로 적용한다.
- `--reload`: 변경 사항을 적용한다.

#### 내부 호스트로 포트 포워딩
내부 네트워크의 특정 호스트로 포트 포워딩을 설정할 수도 있다. 예를 들어, 외부에서 들어오는 TCP 트래픽을 포트 8080으로 받아 내부의 호스트 `192.168.1.100`의 포트 80으로 포워딩하고자 할 때의 설정 방법은 다음과 같다:
```bash
# 외부에서 들어오는 TCP 트래픽을 포트 8080으로 받아 내부의 호스트 192.168.1.100의 포트 80으로 포워딩 (일시적)
sudo firewall-cmd --zone=public --add-forward-port=port=8080:proto=tcp:toaddr=192.168.1.100:toport=80

# 외부에서 들어오는 TCP 트래픽을 포트 8080으로 받아 내부의 호스트 192.168.1.100의 포트 80으로 포워딩 (영구적)
sudo firewall-cmd --zone=public --add-forward-port=port=8080:proto=tcp:toaddr=192.168.1.100:toport=80 --permanent

# 변경 사항 적용
sudo firewall-cmd --reload
```
위 명령어에서 사용된 각 옵션의 의미는 다음과 같다:
- `--add-forward-port=port=8080:proto=tcp:toaddr=192.168.1.100:toport=80`: 포트 8080으로 들어오는 TCP 트래픽을 내부 호스트 `192.168.1.100`의 포트 80으로 포워딩한다.

### `firewalld`에서 마스커레이딩 설정
#### 마스커레이딩(Masquerading) 개념
마스커레이딩(Masquerading)은 네트워크 주소 변환(NAT)의 한 형태로, 내부 네트워크의 여러 호스트가 하나의 공용 IP 주소를 통해 외부 네트워크와 통신할 수 있도록 한다. 이는 특히 IPv4 주소가 부족한 상황에서 매우 유용하다.
마스커레이딩은 주로 라우터나 게이트웨이에서 설정되어, 내부 네트워크의 IP 주소를 숨기고 공용 IP 주소로 변환하여 외부로 트래픽을 보낸다. 반환된 트래픽은 다시 내부 IP 주소로 변환되어 내부 호스트로 전달된다.
`firewalld`를 사용하여 마스커레이딩을 설정할 수 있다. 다음은 `firewalld`에서 마스커레이딩을 활성화하는 방법이다.
#### 마스커레이딩 활용 예시
마스커레이딩은 주로 내부 네트워크의 클라이언트가 외부 인터넷에 접근할 때 사용된다. 내부 네트워크는 사설 IP 주소를 사용하고, 외부와의 통신은 공용 IP 주소를 통해 이루어진다. 마스커레이딩을 설정하면 내부의 여러 호스트가 동일한 공용 IP 주소를 사용하여 외부와 통신할 수 있다. 이는 다음과 같은 상황에서 유용하다:

- 소규모 사무실이나 가정에서 여러 장치가 하나의 공용 IP 주소를 통해 인터넷에 접속할 때
- 데이터 센터에서 내부 서버가 외부 서비스와 통신해야 할 때

마스커레이딩은 네트워크 보안과 관리에도 유리하다. 내부 IP 주소가 외부에 노출되지 않으므로 내부 네트워크 구조를 숨길 수 있다. `firewalld`를 사용하면 이러한 마스커레이딩 설정을 쉽게 관리할 수 있다.
#### 마스커레이딩 설정 예시
```bash
# 일시적 마스커레이딩 설정
# public 영역에서 마스커레이딩 활성화 (일시적)
sudo firewall-cmd --zone=public --add-masquerade

# 영구적 마스커레이딩 설정
# public 영역에서 마스커레이딩 활성화 (영구적)
sudo firewall-cmd --zone=public --add-masquerade --permanent

# 변경 사항 적용
sudo firewall-cmd --reload

# 마스커레이딩 비활성화
# public 영역에서 마스커레이딩 비활성화 (일시적)
sudo firewall-cmd --zone=public --remove-masquerade

# public 영역에서 마스커레이딩 비활성화 (영구적)
sudo firewall-cmd --zone=public --remove-masquerade --permanent

# 변경 사항 적용
sudo firewall-cmd --reload
```
#### 마스커레이딩 설정의 의미
- `--zone=public`: 마스커레이딩을 설정할 영역을 지정한다. 이 예시에서는 `public` 영역을 사용한다.
- `--add-masquerade`: 지정된 영역에서 마스커레이딩을 활성화한다.
- `--remove-masquerade`: 지정된 영역에서 마스커레이딩을 비활성화한다.
- `--permanent`: 설정을 영구적으로 적용한다. 이 옵션이 없으면 설정은 시스템 재부팅 시 사라진다.
- `--reload`: 영구적 설정을 적용하기 위해 `firewalld`를 다시 로드한다.